from queue import Queue
import re
from typing import List

import google
from google.protobuf.descriptor import FieldDescriptor

from .common import proto_type_to_python_type


MessageMeta = google._upb._message.MessageMeta
ScalarMapContainer = google._upb._message.ScalarMapContainer
MessageMapContainer = google._upb._message.MessageMapContainer
Descriptor = google._upb._message.Descriptor


def proto_definition_to_strawberry_graphql_schema(proto_def: MessageMeta) -> List[str]:
    # queue to track all definitions to handle
    # construct header
    # - description
    # - imports
    # construct object class
    # - call helper method
    # combine header and object type into a single string
    proto_definitions_to_process = Queue()
    proto_definitions_to_process.put_nowait(proto_def)
    graphql_definitions = []
    while not proto_definitions_to_process.empty():
        proto_def = proto_definitions_to_process.get_nowait()
        header = f'''
        # This definition was generated by the protobuf utility graphql transform. DO NOT EDIT!
        # Source proto: {proto_def.DESCRIPTOR.full_name}
        '''
        imports = ['import strawberry']
        strawberry_type = proto_definition_to_strawberry_type(
            proto_def, imports, proto_definitions_to_process)
        imports_str = "\n".join(imports)
        graphql_definitions.append(
            f'{header}\n{imports_str}\n\n{strawberry_type}\n'
        )
    return graphql_definitions


def proto_definition_to_strawberry_type(
        proto_def: MessageMeta, imports: List[str], definition_queue, indent_count=0) -> str:
    return _proto_definition_to_strawberry_type(proto_def.DESCRIPTOR, imports, definition_queue)


def _proto_definition_to_strawberry_type(
        proto_descriptor: Descriptor, imports: List[str], definition_queue, indent_count=0) -> str:
    # WARNING: This makes the assumption that used message_types are defined in a file in the same
    #          folder with a name that is the snake case version of the definition name.
    # proto_def.DESCRIPTOR.nested_types
    # define class signature and docstring
    line_prefix = indent_count * '\t'
    lines = [
        line_prefix + '@strawberry.type',
        line_prefix + f'class {proto_descriptor.name}:\n',
    ]

    # for each nested type call self and with an indent count of 1 and add to string after signature
    for nested_class in proto_descriptor.nested_types:

        nested_str = _proto_definition_to_strawberry_type(
            nested_class, imports, definition_queue, indent_count=indent_count+1)
        lines.append(f'{nested_str}\n')

    # for each field
    sorted_fields = sorted(proto_descriptor.fields, key=lambda f: f.number)
    for field in sorted_fields:
        # Handle nested messages
        if field.type == FieldDescriptor.TYPE_MESSAGE:
            # add other protobuf types to the import list and add to queue of definitions to handle
            filename = re.sub(r'(?<!^)(?=[A-Z])', '_', field.message_type.name).lower()
            imports.append(f'from {filename}_gql import {field.message_type.name}')
            field_type = field.message_type.name
        else:
            # support built in python types
            # TODO: handle group and enum types
            if field.type in proto_type_to_python_type:
                field_type = proto_type_to_python_type[field.type]
            else:
                print(f"ERROR: Type {field.type} is not supported")
                continue
        lines.append(
            line_prefix + f'\t{field.name}: {field_type}'
        )
    return '\n'.join(lines)


def proto_definition_to_graphql_type(proto_def: MessageMeta) -> str:
    pass


def proto_definition_to_graphql_query(proto_def: MessageMeta) -> str:
    """Generated the client side graphql query for protobuf object as a string.
    Args:
        proto_def (MessageMeta): protobuf class to convert to a query.
    Returns:
        str: protobuf query
    """
    return _proto_definition_to_graphql_query(proto_def.DESCRIPTOR)


def _proto_definition_to_graphql_query(proto_descriptor: Descriptor, depth=1) -> str:
    # Sort fields based on number to provide a more reproducible order
    # Unsorted order matches that of file definition order even though there is no change to the
    # underlying protobuf if a field is moved. This makes the code unnecessarily unstable.
    sorted_fields = sorted(proto_descriptor.fields, key=lambda f: f.number)

    query = '{'
    for field in sorted_fields:
        tab_str = "\t"*depth

        # Works completely for: scalars, list of scalars
        # Forms base for: nest messages, repeated messages, dictionaries
        query += f'\n{tab_str}{field.name}'

        # Handle nested messages
        if field.type == FieldDescriptor.TYPE_MESSAGE:
            query += ' '
            query += _proto_definition_to_graphql_query(field.message_type, depth=depth+1)

    return f'{query}\n{tab_str[:-1]}' + '}'
