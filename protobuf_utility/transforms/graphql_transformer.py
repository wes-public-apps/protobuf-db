from collections import OrderedDict
import logging
from queue import Queue
from typing import Any, Dict, Set

import google
from google.protobuf.descriptor import FieldDescriptor

from .common import proto_type_to_python_type


_LOGGER = logging.getLogger(__name__)


MessageMeta = google._upb._message.MessageMeta
ScalarMapContainer = google._upb._message.ScalarMapContainer
MessageMapContainer = google._upb._message.MessageMapContainer
Descriptor = google._upb._message.Descriptor
EnumDescriptor = google._upb._message.EnumDescriptor


def construct_definition_tree(root) -> Any:
    definition_dict = OrderedDict()

    # Walk root descriptor to all childen and populate queue of descriptors
    # for each descriptor create definition based on full name
    def set_dict(path: str, value):
        keys = path.split('.')
        dict_ = definition_dict
        for key in keys[:-1]:
            if key in dict_:
                pass
            else:
                dict_[key] = OrderedDict()
            dict_ = dict_[key]
        dict_[keys[-1]] = value

    def _handle_descriptor(descriptor: Any) -> None:
        if isinstance(descriptor, FieldDescriptor):
            set_dict(descriptor.full_name, _handle_field(descriptor))
        if isinstance(descriptor, EnumDescriptor):
            values = [
                f'\t{value.name} = {value.number}'
                for value in descriptor.values
            ]
            set_dict(descriptor.full_name, values)
            return
        if isinstance(descriptor, Descriptor):
            # loop over every field and walk
            for field in descriptor.fields:
                set_dict(field.full_name, _handle_field(field))
            return

    def _handle_field(field: FieldDescriptor) -> str:

        # if field type is a message
        if field.type == FieldDescriptor.TYPE_MESSAGE:
            _handle_descriptor(field.message_type)
            type_ = field.message_type.full_name
        # if field type is an enum
        elif field.type == FieldDescriptor.TYPE_ENUM:
            _handle_descriptor(field.enum_type)
            type_ = field.enum_type.full_name
        # if field type is a python type return a string 'field: type'
        elif field.type in proto_type_to_python_type:
            type_ = proto_type_to_python_type[field.type]

        # Handle Repeated Types
        if field.label == FieldDescriptor.LABEL_REPEATED:
            return f'{field.name}: "List[{type_}]"'
        else:
            return f'{field.name}: "{type_}"'

    _handle_descriptor(root.DESCRIPTOR)
    return definition_dict


class SetQueue(Queue):
    def __init__(self, maxsize: int = 0) -> None:
        super().__init__(maxsize)
        self._processed_items = set()

    def put(self, item, block=True, timeout=None):
        if item.full_name not in self._processed_items:
            self._processed_items.add(item.full_name)
            super().put(item, block, timeout)


def proto_definition_to_strawberry_types(proto_def: MessageMeta) -> str:
    # collect any related definitions into a queue so they can be generated
    proto_definitions_to_process = SetQueue()
    proto_definitions_to_process.put_nowait(proto_def.DESCRIPTOR)

    # Define file header
    header = '# This definition was generated by the protobuf utility graphql transform.'
    header += f'\n# Source proto: {proto_def.DESCRIPTOR.full_name}'

    # Define loop variables
    imports = {'import strawberry'}
    graphql_definitions = []
    while not proto_definitions_to_process.empty():
        proto_descriptor = proto_definitions_to_process.get_nowait()
        strawberry_type = proto_descriptor_to_strawberry_type(
            proto_descriptor, imports, proto_definitions_to_process)
        graphql_definitions.append(strawberry_type)

    # collect content into a single string
    imports_str = "\n".join(list(imports))
    graphql_definitions.reverse()
    content = '\n\n'.join(graphql_definitions)
    return f'{header}\n{imports_str}\n\n{content}\n'


def proto_descriptor_to_strawberry_type(
        proto_descriptor: Any, imports: Set[str], definition_queue, indent_count=0) -> str:
    if isinstance(proto_descriptor, Descriptor):
        return _message_descriptor_to_strawberry_type(
            proto_descriptor, imports, definition_queue, indent_count,
            proto_descriptor.name)
    elif isinstance(proto_descriptor, EnumDescriptor):
        return _enum_descriptor_to_strawberry_type(
            proto_descriptor, imports, indent_count)
    else:
        _LOGGER.error(
            f'TO STRAWBERRY TYPE: Definition of Type {type(proto_descriptor)} cannot be processed.')
        return ''


def _message_descriptor_to_strawberry_type(
        proto_descriptor: Descriptor, imports: Set[str], definition_queue,
        indent_count=0, root_type=None) -> str:
    # WARNING: This makes the assumption that used message_types are defined in a file in the same
    #          folder with a name that is the snake case version of the definition name.

    # handle nested
    # TODO: how can we inject into any parent classes if they already exist

    # define class signature and docstring
    line_prefix = indent_count * '\t'
    lines = []

    # for each nested enum
    lines.extend([
        line_prefix + '@strawberry.type',
        line_prefix + f'class {proto_descriptor.name}:'
    ])
    for nested_enum in proto_descriptor.enum_types:
        nested_enum_str = _enum_descriptor_to_strawberry_type(nested_enum, imports, indent_count+1)
        lines.append(f'{nested_enum_str}\n')

    # for each nested message call self with an incremented indent count
    for nested_class in proto_descriptor.nested_types:
        nested_str = _message_descriptor_to_strawberry_type(
            nested_class, imports, definition_queue, indent_count+1, root_type)
        lines.append(f'{nested_str}\n')

    # for each field
    def handle_complex_types(complex_type) -> str:
        # not nested external type
        if complex_type.name == complex_type.full_name:
            definition_queue.put_nowait(complex_type)

        # nested external type
        elif root_type not in complex_type.full_name:
            definition_queue.put_nowait(complex_type)

        # nested object on current definitions
        else:
            pass

        return complex_type.full_name

    sorted_fields = sorted(proto_descriptor.fields, key=lambda f: f.number)
    for field in sorted_fields:

        # Complex Types
        # TODO: handle group
        if field.type == FieldDescriptor.TYPE_MESSAGE:
            field_type = handle_complex_types(field.message_type)
        elif field.type == FieldDescriptor.TYPE_ENUM:
            field_type = handle_complex_types(field.enum_type)
        # Python Types
        else:
            if field.type in proto_type_to_python_type:
                field_type = proto_type_to_python_type[field.type]
            else:
                field_type = ''

        # Document unsupported types
        if not field_type:
            _LOGGER.error(
                f"TO STRAWBERRY TYPE: Field type {field.type} is not supported")
            continue

        lines.append(
            line_prefix + f'\t{field.name}: "{field_type}"'
        )
    return '\n'.join(lines)


def _enum_descriptor_to_strawberry_type(
        enum_definition: EnumDescriptor, imports: Set[str], indent_count=0) -> str:
    line_prefix = '\t' * indent_count
    imports.add('from enum import Enum')

    # class definition
    lines = [
        '@strawberry.enum',
        f'class {enum_definition.name}(Enum):',
    ]
    for value in enum_definition.values:
        lines.append(f'\t{value.name} = {value.number}')

    # adjust spacing based on context
    return '\n'.join(
        [
            f'{line_prefix}{line}'
            for line in lines
        ]
    )


def proto_definition_to_graphql_type(proto_def: MessageMeta) -> str:
    pass


def proto_definition_to_graphql_query(proto_def: MessageMeta) -> str:
    """Generated the client side graphql query for protobuf object as a string.
    Args:
        proto_def (MessageMeta): protobuf class to convert to a query.
    Returns:
        str: protobuf query
    """
    return _proto_definition_to_graphql_query(proto_def.DESCRIPTOR)


def _proto_definition_to_graphql_query(proto_descriptor: Descriptor, depth=1) -> str:
    # Sort fields based on number to provide a more reproducible order
    # Unsorted order matches that of file definition order even though there is no change to the
    # underlying protobuf if a field is moved. This makes the code unnecessarily unstable.
    sorted_fields = sorted(proto_descriptor.fields, key=lambda f: f.number)

    query = '{'
    for field in sorted_fields:
        tab_str = "\t"*depth

        # Works completely for: scalars, list of scalars
        # Forms base for: nest messages, repeated messages, dictionaries
        query += f'\n{tab_str}{field.name}'

        # Handle nested messages
        if field.type == FieldDescriptor.TYPE_MESSAGE:
            query += ' '
            query += _proto_definition_to_graphql_query(field.message_type, depth=depth+1)

    return f'{query}\n{tab_str[:-1]}' + '}'
