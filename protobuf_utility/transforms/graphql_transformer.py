import logging
from queue import Queue
import re
from typing import Any, Dict, Set

import google
from google.protobuf.descriptor import FieldDescriptor

from .common import proto_type_to_python_type


_LOGGER = logging.getLogger(__name__)


MessageMeta = google._upb._message.MessageMeta
ScalarMapContainer = google._upb._message.ScalarMapContainer
MessageMapContainer = google._upb._message.MessageMapContainer
Descriptor = google._upb._message.Descriptor
EnumDescriptor = google._upb._message.EnumDescriptor


def proto_definition_to_strawberry_types(proto_def: MessageMeta) -> Dict[str, str]:
    # collect any related definitions into a queue so they can be generated
    proto_definitions_to_process = Queue()
    proto_definitions_to_process.put_nowait(proto_def.DESCRIPTOR)
    graphql_definitions = {}
    while not proto_definitions_to_process.empty():
        proto_descriptor = proto_definitions_to_process.get_nowait()
        header = '# This definition was generated by the protobuf utility graphql transform.'
        header += f'\n# Source proto: {proto_descriptor.full_name}'
        imports = {'import strawberry'}
        strawberry_type = proto_descriptor_to_strawberry_type(
            proto_descriptor, imports, proto_definitions_to_process)
        imports_str = "\n".join(list(imports))
        graphql_definitions[proto_descriptor.full_name] = \
            f'{header}\n{imports_str}\n\n{strawberry_type}\n'
    return graphql_definitions


def proto_descriptor_to_strawberry_type(
        proto_descriptor: Any, imports: Set[str], definition_queue, indent_count=0) -> str:
    if isinstance(proto_descriptor, Descriptor):
        return _message_descriptor_to_strawberry_type(
            proto_descriptor, imports, definition_queue, indent_count,
            proto_descriptor.name)
    elif isinstance(proto_descriptor, EnumDescriptor):
        return _enum_descriptor_to_strawberry_type(
            proto_descriptor, imports, indent_count)
    else:
        _LOGGER.error(
            f'TO STRAWBERRY TYPE: Definition of Type {type(proto_descriptor)} cannot be processed.')
        return ''


def _message_descriptor_to_strawberry_type(
        proto_descriptor: Descriptor, imports: Set[str], definition_queue,
        indent_count=0, root_type=None) -> str:
    # WARNING: This makes the assumption that used message_types are defined in a file in the same
    #          folder with a name that is the snake case version of the definition name.

    # define class signature and docstring
    line_prefix = indent_count * '\t'
    lines = []

    # for each nested enum
    lines.extend([
        line_prefix + '@strawberry.type',
        line_prefix + f'class {proto_descriptor.name}:'
    ])
    for nested_enum in proto_descriptor.enum_types:
        nested_enum_str = _enum_descriptor_to_strawberry_type(nested_enum, imports, indent_count+1)
        lines.append(f'{nested_enum_str}\n')

    # for each nested message call self with an incremented indent count
    for nested_class in proto_descriptor.nested_types:
        nested_str = _message_descriptor_to_strawberry_type(
            nested_class, imports, definition_queue, indent_count+1, root_type)
        lines.append(f'{nested_str}\n')

    # for each field
    def handle_complex_types(complex_type) -> str:
        field_type: str = complex_type.full_name

        # not nested external type
        if complex_type.name == complex_type.full_name:
            name = complex_type.name

        # nested external type
        elif root_type not in complex_type.full_name:
            name = complex_type.full_name.split('.')[0]
            # add to queue to process
            definition_queue.put_nowait(complex_type)

        # nested object on current definitions
        else:
            return field_type[field_type.find('.', field_type.find(root_type))+1:]

        filename = re.sub(r'(?<!^)(?=[A-Z])', '_', name).lower()
        imports.add(f'from {filename}_gql import {name}')
        return field_type

    sorted_fields = sorted(proto_descriptor.fields, key=lambda f: f.number)
    for field in sorted_fields:

        # Complex Types
        # TODO: handle group
        if field.type == FieldDescriptor.TYPE_MESSAGE:
            field_type = handle_complex_types(field.message_type)
        elif field.type == FieldDescriptor.TYPE_ENUM:
            field_type = handle_complex_types(field.enum_type)
        # Python Types
        else:
            if field.type in proto_type_to_python_type:
                field_type = proto_type_to_python_type[field.type]
            else:
                field_type = ''

        # Document unsupported types
        if not field_type:
            _LOGGER.error(
                f"TO STRAWBERRY TYPE: Field type {field.type} is not supported")
            continue

        lines.append(
            line_prefix + f'\t{field.name}: "{field_type}"'
        )
    return '\n'.join(lines)


def _enum_descriptor_to_strawberry_type(
        enum_definition: EnumDescriptor, imports: Set[str], indent_count=0) -> str:
    line_prefix = '\t' * indent_count
    imports.add('from enum import Enum')

    # class definition
    lines = [
        '@strawberry.enum',
        f'class {enum_definition.name}(Enum):',
    ]
    for value in enum_definition.values:
        lines.append(f'\t{value.name} = {value.number}')

    # adjust spacing based on context
    return '\n'.join(
        [
            f'{line_prefix}{line}'
            for line in lines
        ]
    )


def proto_definition_to_graphql_type(proto_def: MessageMeta) -> str:
    pass


def proto_definition_to_graphql_query(proto_def: MessageMeta) -> str:
    """Generated the client side graphql query for protobuf object as a string.
    Args:
        proto_def (MessageMeta): protobuf class to convert to a query.
    Returns:
        str: protobuf query
    """
    return _proto_definition_to_graphql_query(proto_def.DESCRIPTOR)


def _proto_definition_to_graphql_query(proto_descriptor: Descriptor, depth=1) -> str:
    # Sort fields based on number to provide a more reproducible order
    # Unsorted order matches that of file definition order even though there is no change to the
    # underlying protobuf if a field is moved. This makes the code unnecessarily unstable.
    sorted_fields = sorted(proto_descriptor.fields, key=lambda f: f.number)

    query = '{'
    for field in sorted_fields:
        tab_str = "\t"*depth

        # Works completely for: scalars, list of scalars
        # Forms base for: nest messages, repeated messages, dictionaries
        query += f'\n{tab_str}{field.name}'

        # Handle nested messages
        if field.type == FieldDescriptor.TYPE_MESSAGE:
            query += ' '
            query += _proto_definition_to_graphql_query(field.message_type, depth=depth+1)

    return f'{query}\n{tab_str[:-1]}' + '}'
